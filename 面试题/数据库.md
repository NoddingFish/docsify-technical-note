## Mysql

1. #### `MySQL InnoDB` 的特点？

   - 提供了具有事务提交、回滚和崩溃修复能力的事务安全型表。
   - 提供了行锁，提供与 `Oracle` 类型一致的不加锁读取。
   - 表中不需要扩大锁定，因为 `InnoDB` 的列锁定适宜非常小的空间。
   - 提供外键约束。
   - 设计目标是处理大容量数据库系统，它的 `CPU` 利用率是其它基于磁盘的关系数据库引擎所不能比的。
   - 在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。 
   - 把数据和索引存放在表空间里，可能包含多个文件，这与其它的不一样，举例来说，在 `MyISAM` 中，表被存放在单独的文件中。
   - 表的大小只受限于操作系统的文件大小，一般为 `2 GB` 。
   - 所有的表都保存在同一个数据文件` ibdata1` 中（也可能是使用独立的表空间文件的多个文件，使用共享表空间时比较不好备份单独的表），免费的方案可以是可以是拷贝数据文件、备份 `binlog` ，或者用 `mysqldump` 。

   > [mysql的InnoDB引擎的四大特点](https://www.cnblogs.com/zhipeng-wang/p/14480951.html)
   >
   > [mysql数据表引擎InnoDB和MyISAM的特点](https://blog.csdn.net/chenjiayi_yun/article/details/45746989)

   

2. #### 乐观锁和悲观锁的区别？

   > [乐观锁和悲观锁的区别（最全面的分析）](https://baijiahao.baidu.com/s?id=1604426171880146821&wfr=spider&for=pc)

   ```sql
   # 悲观锁
   select * from stock where product_id = xxxx for update;
   
   update stock set count = count - 1 where product_id = xxxx and count > 0;
   
   #乐观锁
   update stock set count = count - 1 and version = version + 1 where product_id = xxxx and count > 0 and version = xxxx;
   ```

   

3. #### 数据库隔离级别是什么？有什么作用？

4.  #### `MySQL` 主从同步的基本原理。

5. #### 如何从一张表中查出 `name` 字段包含 `“XYZ”` 的所有行？

6. #### 索引数据结构（字典 `+BitTree` ）

7. #### 如何优化数据库性能（索引、分库分表、批量操作、分页算法、升级硬盘SSD、业务优化、主从部署）

8.  #### `SQL` 什么情况下不会使用索引（不包含，不等于，函数）

9. #### 一般在什么字段上建索引（过滤数据最多的字段）

10.  #### `MySQL` ，`B+` 索引实现，行锁实现， `SQL` 优化

    > - 尽量避免 `NULL`；
    >
    > - 尽量只对小数精确计算时才使用 `decimal` -列如财务数据。但在数据量较大时，可以考虑使用 `bigint` 代替 `decimal` ，将需要存储的货币单位根据小数的位数乘以相应的倍数存储；
    >
    > - 时间格式：除特殊情况，通常使用 `TIMESTAMP` （1970年1月1日 午夜 - 2038年）比 `DATETIME` （1001年-9999年）空间效率更高。不推荐将时间存整数

11. #### 如何解决高并发减库存问题

12.  #### `mysql` 存储引擎中索引的实现机制；

13. #### 数据库事务的几种粒度；

14. #### 行锁，表锁；乐观锁，悲观锁



## Redis

1. #### Redis 缓存击穿、穿透、雪崩的原因以及解决方案

   ##### 缓存穿透

   1. 在接口层增加校验，不合法的参数直接返回。不相信任务调用方，根据自己提供的 `API` 接口规范来，作为被调用方，要考虑可能任何的参数传值

   2. 在缓存查不到， `DB` 中也没有的情况，可以将对应的 `key` 的 `value` 写为 `null`，或者其他特殊值写入缓存，同时将过期失效时间设置短一点，以免影响正常情况。这样是可以防止反复用同一个 `ID` 来暴力攻击

   3. 正常用户是不会这样暴力功击，只有是恶意者才会这样做，可以在网关 `NG` 作一个配置项，为每一个 `IP` 设置访问阈值。

   4. 高级用户布隆过滤器（ `Bloom Filter` ), 这个也能很好地防止缓存穿透。原理就是利用高效的数据结构和算法快速判断出你这个 `Key` 是否在 `DB` 中存在，不存在你 `return` 就好了，存在你就去查了 `DB` 刷新 `KV` 再 `return` 。

      ###### 参考资料

      > [参考资料：布隆过滤器(bloom filter)及php和redis实现布隆过滤器的方法](http://www.gaodaima.com/87289.html)
      >
      > [参考资料：布隆过滤器(bloom filter)介绍以及php和redis实现布隆过滤器实现方法](https://blog.csdn.net/slqgenius/article/details/108757558)
      >
      > [参考资料：一看就懂系列之 详解redis的bitmap在亿级项目中的应用](https://blog.csdn.net/u011957758/article/details/74783347)

   

   ---

   

   ##### 缓存雪崩

   批量往 `redis` 存数据的时候，把每个 `key` 的失效时间加上个随机数，比如 1-5 分钟随机，这样的话就能保证数据不会在同一个时间大面积失效。

   

   ---

   

   ##### 缓存击穿

   - 把这个热点 `key` 设置为永久有效

   - 使用互斥锁，这是比较常用的方法，简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去查询数据库，而是先使用缓存工具的某些带成功操作返回值的操作（比如 `Redis` 的 `SETNX` 或者 `Memcache` 的 `ADD` ）去 set 一个 `mutex key` ，当操作返回成功时，再进行查询数据库的操作并回设缓存；否则，就重试整个 `get` 缓存的方法。

     ###### 代码实现：

     ```php
     function get($key) {
         $value = $redis->get($key);
         if ($value == null) {
             //不存在，设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能查询数据库
             if ($redis->setnx("key_mutex", 1, 3 * 60) == 1){
                 $value = "";//这是查询数据库文件
                 $redis->set(key, value, expire_secs);
                 $redis->del(key_mutex);
             }else{
                 //这个时候代表同时候的其他线程已经查询数据库并回设到缓存了，这时候重试获取缓存值即可
                 sleep(50);
                 get(key);  //重试
             }
         } else {
             //存在则直接返回
             return $value;
         }
     }
     ```

   

2. #### `Redis` ， `RDB` 和 `AOF` ，如何做高可用、集群

3. #### 列举一个常用的消息中间件，如果消息要保证顺序如何实现？

4. #### 如何解决缓存单机热点问题

5. #### 什么是布隆过滤器，其实现原理是？ `False positive` 指的是？