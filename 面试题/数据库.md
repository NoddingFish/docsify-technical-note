## Mysql

1.  `MySQL InnoDB` 的特点？

2. 乐观锁和悲观锁的区别？

3. 数据库隔离级别是什么？有什么作用？

4.  `MySQL` 主从同步的基本原理。

5. 如何从一张表中查出 `name` 字段包含“XYZ”的所有行？

6. 索引数据结构（字典 `+BitTree` ）

7. 如何优化数据库性能（索引、分库分表、批量操作、分页算法、升级硬盘SSD、业务优化、主从部署）

8.  `SQL` 什么情况下不会使用索引（不包含，不等于，函数）

9. 一般在什么字段上建索引（过滤数据最多的字段）

10.  `MySQL` ，`B+` 索引实现，行锁实现， `SQL` 优化

    > - 尽量避免 `NULL`；
    >
    > - 尽量只对小数精确计算时才使用 `decimal` -列如财务数据。但在数据量较大时，可以考虑使用 `bigint` 代替 `decimal` ，将需要存储的货币单位根据小数的位数乘以相应的倍数存储；
    >
    > - 时间格式：除特殊情况，通常使用 `TIMESTAMP` （1970年1月1日 午夜 - 2038年）比 `DATETIME` （1001年-9999年）空间效率更高。不推荐将时间存整数

11. 如何解决高并发减库存问题

12.  `mysql` 存储引擎中索引的实现机制；

13. 数据库事务的几种粒度；

14. 行锁，表锁；乐观锁，悲观锁



## Redis

1. #### Redis 缓存击穿、穿透、雪崩的原因以及解决方案

   ##### 缓存穿透

   1. 在接口层增加校验，不合法的参数直接返回。不相信任务调用方，根据自己提供的 `API` 接口规范来，作为被调用方，要考虑可能任何的参数传值

   2. 在缓存查不到， `DB` 中也没有的情况，可以将对应的 `key` 的 `value` 写为 `null`，或者其他特殊值写入缓存，同时将过期失效时间设置短一点，以免影响正常情况。这样是可以防止反复用同一个 `ID` 来暴力攻击

   3. 正常用户是不会这样暴力功击，只有是恶意者才会这样做，可以在网关 `NG` 作一个配置项，为每一个 `IP` 设置访问阈值。

   4. 高级用户布隆过滤器（ `Bloom Filter` ), 这个也能很好地防止缓存穿透。原理就是利用高效的数据结构和算法快速判断出你这个 `Key` 是否在 `DB` 中存在，不存在你 `return` 就好了，存在你就去查了 `DB` 刷新 `KV` 再 `return` 。

      ###### 参考资料

      > [参考资料：布隆过滤器(bloom filter)及php和redis实现布隆过滤器的方法](http://www.gaodaima.com/87289.html)
      >
      > [参考资料：布隆过滤器(bloom filter)介绍以及php和redis实现布隆过滤器实现方法](https://blog.csdn.net/slqgenius/article/details/108757558)
      >
      > [参考资料：一看就懂系列之 详解redis的bitmap在亿级项目中的应用](https://blog.csdn.net/u011957758/article/details/74783347)

   

   ---

   

   ##### 缓存雪崩

   批量往 `redis` 存数据的时候，把每个 `key` 的失效时间加上个随机数，比如 1-5 分钟随机，这样的话就能保证数据不会在同一个时间大面积失效。

   

   ---

   

   ##### 缓存击穿

   - 把这个热点 `key` 设置为永久有效

   - 使用互斥锁，这是比较常用的方法，简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去查询数据库，而是先使用缓存工具的某些带成功操作返回值的操作（比如 `Redis` 的 `SETNX` 或者 `Memcache` 的 `ADD` ）去 set 一个 `mutex key` ，当操作返回成功时，再进行查询数据库的操作并回设缓存；否则，就重试整个 `get` 缓存的方法。

     ###### 代码实现：

     ```php
     function get($key) {
         $value = $redis->get($key);
         if ($value == null) {
             //不存在，设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能查询数据库
             if ($redis->setnx("key_mutex", 1, 3 * 60) == 1){
                 $value = "";//这是查询数据库文件
                 $redis->set(key, value, expire_secs);
                 $redis->del(key_mutex);
             }else{
                 //这个时候代表同时候的其他线程已经查询数据库并回设到缓存了，这时候重试获取缓存值即可
                 sleep(50);
                 get(key);  //重试
             }
         } else {
             //存在则直接返回
             return $value;
         }
     }
     ```

   

2. #### `Redis` ， `RDB` 和 `AOF` ，如何做高可用、集群

3. #### 列举一个常用的消息中间件，如果消息要保证顺序如何实现？

4. #### 如何解决缓存单机热点问题

5. #### 什么是布隆过滤器，其实现原理是？ `False positive` 指的是？