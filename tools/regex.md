# 正则表达式

推荐学习网站

> [RegexLearn](https://regexlearn.com/zh-cn)
>
> [https://wangwl.net/static/projects/visualRegex#](https://wangwl.net/static/projects/visualRegex#)

## 语法

### 引用组（Group Reference）

?> 案列：单词 `ha` 和 `haa` 分组如下。第一组用 `\1` 来避免重复书写。这里的 `1` 表示分组的顺序。请在表达式的末尾键入 `\2` 以引用第二组。

```文本
ha-ha,haa-haa
```

```正则表达式
/(ha)-\1,(haa)-\2/g
```



### 括号 `(?: )`: 非捕获分组（Non-capturing Grouping）

?> 案列：您可以对表达式进行分组，并确保它不被引用捕获。例如，下面有两个分组，但我们用 `\1` 引用的第一个组实际上是指向第二个组，因为第一个是未被捕获的分组。

```文本
ha-ha,haa-haa
```

```正则表达式
/(?:ha)-ha,(haa)-\1/g
```

> [[正则捕获组与非捕获组](https://segmentfault.com/a/1190000021043947)](https://segmentfault.com/a/1190000021043947)



### 竖线 `|` （Alternation）

?> 案列：竖线允许一个表达式包含多个不同的分支。所有分支用 `|` 分隔。和在字符层面上运作的字符集 `[abc]` 不同，分支在表达式层面上运作。例如，下面的表达式同时匹配 `cat` 和 `rat`。请在末尾添加另一个 `|`，并输入 `dog` 以匹配所有单词。

```文本
cat rat dog
```

```正则表达式
/(c|r)at|dog/g
```



## 零宽断言（Lookarounds）

?> 如果我们希望正在写的词语出现在另一个词语之前或之后，我们需要使用「零宽断言」。请前往下一步骤，学习如何使用「零宽断言」。

### 正向先行断言: `(?=)`（Positive Lookahead）

?> 案列：例如，我们要匹配文本中的小时值。为了只匹配后面有 `PM` 的数值，我们需要在表达式后面使用正向先行断言 `(?=)`，并在括号内的 `=` 后面添加 `PM`。

```文本
Date: 4 Aug 3PM
```

```正则表达式
/\d+(?=PM)/g
```

### 负向先行断言: `(?!)`（Negative Lookahead）

?> 例如，我们要在文本中匹配除小时值以外的数字。我们需要在表达式后面使用负向先行断言 `(?!)`，并在括号内的 `!` 后面添加 `PM`，从而只匹配没有 `PM` 的数值。

```文本
Date: 4 Aug 3PM
```

```正则表达式
/\d+(?!PM)/g
```

### 正向后行断言: `(?<=)`（Positive Lookbehind）

?> 例如，我们要匹配文本中的金额数。为了只匹配前面带有 `$` 的数字。我们要在表达式前面使用正向后行断言 `(?<=)`，并在括号内的 `=` 后面添加 `\$`。

```文本
Product Code: 1064 Price: $5
```

```正则表达式
/(?<=\$)\d+/g
```

### 负向后行断言: `(?<!)`（Negative Lookbehind）

?> 例如，我们要在文本中匹配除价格外的数字。为了只匹配前面没有 `$` 的数字，我们要在表达式前用负向后行断言 `(?<!)`，并在括号内的 `!` 后面添加 `\$`。

```文本
Product Code: 1064 Price: $5
```

```正则表达式
# 匹配到 1064
/(?<!\$)\d+/g
```



## 标志（Flags）

?> 标志改变表达式的输出。这就是标志也称为 `修饰符` 的原因。标志决定表达式是否将文本视作单独的行处理，是否区分大小写，或者是否查找所有匹配项。请继续下一步步骤以学习标志。

## 全局标志（Global）

?> 全局标志使表达式选中所有匹配项，如果不启用全局标志，那么表达式只会匹配第一个匹配项。现在，请启用全局标志，以便匹配所有匹配项。

```文本
domain.com, test.com, site.com
```

```正则表达式
# 不启用全局标志，匹配到：domain.com
/\w+\.com/

# 启用全局标志，匹配到： domain.com test.com site.com
/\w+\.com/g
```

### 多行标志（Multiline）

?> 正则表达式将所有文本视作一行。但如果我们使用了多行标志，它就会单独处理每一行。这次，我们将根据每一行行末的规律来写出表达式，现在，请启用多行标志来查找所有匹配项。

```文本
domain.com
test.com
site.com
```

```正则表达式
# 不使用多行标志，匹配到：site.com
/\w+\.com$/g

# 使用多行标志，匹配到： domain.com test.com site.com
/\w+\.com$/gm
```

### 忽略大小写标志（Case Insensitive）

```文本
DOMAIN.COM
TEST.COM
SITE.COM
```

```正则表达式
# 不使用忽略大小标志，未匹配到
/\w+\.com$/gm

# 使用忽略大小标志，匹配到： DOMAIN.COM TEST.COM SITE.COM
/\w+\.com$/gmi
```



## 贪婪匹配（Greedy Matching）

?> 正则表达式默认执行贪婪匹配。这意味着匹配内容会尽可能长。请看下面的示例，它匹配任何以 `r` 结尾的字符串，以及前面带有该字符串的文本，但它不会在第一个 `r` 处停止匹配。

```文本
ber beer beeer beeeer
```

```正则表达式
/.*r/
# 匹配到：ber beer beeer beeeer
```

## 懒惰匹配（Lazy Matching）

?> 与贪婪匹配不同，懒惰匹配在第一次匹配时停止。下面的例子中，在 `*` 之后添加 `?`，将查找以 `r` 结尾且前面带有任意字符的第一个匹配项。这意味着本次匹配将会在第一个字母 `r` 处停止。

```文本
ber beer beeer beeeer
```

```正则表达式
/.*?r/
# 匹配到：ber
```



#### 恭喜，您已完成所有步骤！

您可以随时返回到前面的步骤，并且可以轻松浏览所有已通过的步骤。以上实例都来自：[https://regexlearn.com/zh-cn](https://regexlearn.com/zh-cn/learn/regex101)



## 特殊字符

| 语法 | 相同语法           | 解释                                                         |
| :--- | ------------------ | ------------------------------------------------------------ |
| `\w` | `/[a-zA-Z0-9_]/g`  | 单词字符，表达式 \w 用于查找字母、数字和下划线。让我们用表达式 \w 来查找文本中的单词字符。 |
| `\W` | `/[^a-zA-Z0-9_]/g` | 非单词字符，匹配除字母、数字和下划线之外的字符。             |
| `\d` | `/[0-9]/g`         | 数字字符，仅用来匹配数字。                                   |
| `\D` | `/[^0-9]/g`        | 非数字字符，匹配除数字之外的字符。                           |
| `\s` |                    | 空白符，仅匹配空白字符。                                     |
| `\S` |                    | 非空白符，匹配除空白符之外的字符。                           |



## 经典案例

1. 千分位格式化

   给 `100000000000` 格式化为： `100,000,000,000`

   `Js` 实现

   ```js
   let str = '100000000000';
   
   let res = str.replace(/\B(?=(\d{3})+$)/g, ',');
   
   console.log(res); // 100,000,000,000
   ```

   `PHP` 实现

   ```php
   $str = '100000000000';
   
   $res = preg_replace('/\B(?=(\d{3})+$)/', ',', $str);
   
   echo $res . PHP_EOL; // 100,000,000,000
   ```

   